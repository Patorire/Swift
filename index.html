<!doctype html>
<html>

<body background="https://www.apple.com/newsroom/images/tile-images/wwdc23/latest/Apple-WWDC23-event-announcement-hero.jpg.og.jpg?202305311711" style="background-attachment: fixed; background-repeat: no-repeat; background-size: 100% 100%;">
<style>
	a:link{
		color:green;
	}
	a:visited{
		color:green;
	}
</style>
<body>
<center>
<h1 style="color: white;">SWIFT</h1>
</center>
<h3 style="color: white;"><a href="https://www.apple.com/es/swift/#:~:text=Swift%20es%20un%20intuitivo%20lenguaje,puede%20hacer%20realidad%20sus%20ideas."> ¿Qué es Swift?</a></h3>
<p style="color:white;">Swift es un lenguaje de programación creado por Apple, permite diseñar apps para iOS, Mac, el Apple TV y el Apple Watch. Swift es de código abierto y muy fácil de usar, además este se integra perfectamente con código en Objective-C, ofreciendo seguridad y ahorrando tiempo.</p>
<p style="color:white;">Este lenguaje fue presentado de manera oficial en el año 2014 durante la <a href="https://www.apple.com/es/newsroom/2023/05/apples-worldwide-developers-conference-to-kick-off-june-5-2023/"> Conferencia Anual de Desarrolladores</a>. En la presentación de Swift explicaron que buscaban un lenguaje de programación que fuera más asequible que las opciones existentes.</p>
<p style="color:white">Swift fue un exito de inmediato. Gracias a sus características se ha vuelo el lenguaje propio de iOS, por lo tanto de alguna o otra manera si se está dispuesto a programar en dispositivos apple, definitivamente se debe de conocer este lenguaje.</p>
<h3 style="color:white">¿Cuales son esas características que han hecho que Swift se asentara tan rápidamente?</h3>
<ul style="color:white">
	<li>Destaca de manera contundente el hecho de su seguridad y rapidez. La seguridad de Swift se basa en la reducción de la posibilidad de error a la hora de escribir el código. Al basarse en un código más limpio y cuya estructura es menos propensa a incorrecciones, la existencia de errores o problemas se ve reducida considerablemente.</li>
	<li>Swift es un lenguaje que contiene muy pocos errores y que por lo tanto supone una ventaja en el desarrollo digital basado en este código, esto se puede comprobar a la hora de comparar una app de un dispositvo cualquiera con uno de Apple, generalmente su seguridad es major.</li>
	<li>La velocidad de desarrollo es otro factor que ha llevado a Swift a ser un gran lenguaje de programación; su necesidad de mejorar y incluso sustituir a lenguajes como Objecte-C le ha hecho convertirse en uno de los mejores. Hoy en día sigue siendo el lenguaje de programación más rápido que puede utilizarse para cualquier desarrollo de iOS.</li>
	<li>Como última de las características encontramos la evolución constante a la que esta sometido el lenguaje de programación Swift, aprovechando así mejor los avances de las nuevas tecnologías y permitiendo cada vez desarrollos más complejos y funcionales para los usuarios.</li>
</ul>

<h3 style="color: white;">¿Por qué deberías aprender a programar Swift?</h3>
<p style="color:white;">Su facilidad de sintaxis le permite ser un lenguaje que no se dificulta demasiado en su aprendizaje. Un punto muy importante es su comunidad activa, esta está en constante crecimiento, por lo que aprender Swift puede ser muy bueno para adquirir experiencia con el tiempo hasta que Swift se vuelva aún más popular.</p>
<h3 style="color: white;">Variables</h3>
<p style="color: white;">Con variables de Swift nos referimos a espacios de memoria creados en el ordenador, que se encargan del almacenamiento de datos, estos pueden variar su valor cuando sea necesario a la hora de ejecución del programa.</p>
<h3 style="color: white;"><a href="https://keepcoding.io/blog/variables-y-constantes-en-swift/"> ¿Cómo se crean estas variables y constantes?</a></h3>
<p style="color: white;">Si lo que quieres es crear una constante debes de utilizar la palabra clave <strong><em>let</em></strong>, si en cambio quieres crear una variable deberás hacerlo con la palabra clave <strong><em>var.</em></strong><br>Si en algún momento quieres cambiar la variable solo deberas escribir el nombre de la variable que quieras modificar seguido de su nuevo valor. </p>
<h3 style="color: white;"><a href="https://keepcoding.io/blog/tipos-de-datos-en-swift/"> Tipos de datos</a></h3>
<p style="color: white;"> Los tipos de datos se definen como los tipos de valores que se pueden agregar tanto a las diferentes variables como a las que son constantes. Cabe aclarar que los datos de las variables pueden variar pero no puede haber un cambio de tipo de dato (Pasar un dato numérico a un dato de texto).<br>
	<ul style="color: white;">
		<li><strong>String:</strong> Este tipo de dato se utiliza para representar y manipular cadenas de texto. Se pueden crear variables o constantes de este tipo para almacenar información textual. Las cadenas de texto tienen la capacidad de concatenarse utilizando el operador <em><strong>"+"</strong></em>, además permite extraer subcadenas.</li>
		<li><strong>Integer:</strong>Este tipo de dato se utiliza para la representación de números enteros sin decimales. En Swift encontramos diferentes tipos de datos <em><strong>Integer</strong></em>, estos son los siguientes: <em><strong>Int8, Int16, Int32, Int64 y UInt (usado para la representación de datos enteros sin signo).</strong></em></li>
		<li><strong>Float:</strong>Este tipo de dato a diferencia del anterior se utiliza para representar números decimales, concretamente decimales de precisión simple y ocupan 32 bits de memoria.</li>
		<li><strong>Double:</strong>Este tipo de dato también almacena números decimales pero con mayor preción, ya que estos ocupan 64 bits de memoria. Las variables o constantes <strong><em>Double</em></strong> son muy úilizados para calculos científicos o financieros.</li>
		<li><strong>Boolean:</strong>Este tipo de dato es utilizado para representar valores de verdad, teniendo solamente dos posibles valores: <em>true</em> o <em>false</em>. Son muy útiles para las condiciones lógicas y el control de el flujo de ejecución en las estructuras de control como <em><strong>if-else o bucles</strong></em>.</li>
	</ul>
</p>
<h3 style="color: white;">Patrones Creacionales y Estructurales</h3>
<h4 style="color: white;"> Patrones Creacionales</h4>
<p style="color: white;">Los patrones creacionales proporcionan varios mecanismos de creación de objetos que incrementan la flexibilidad y la reutilización del código existente.</p>
<ul style="color: white;">
	<li><a href="https://refactoring.guru/es/design-patterns/factory-method" <strong>Factory Method (Método fábrica/Constructor Virtual):</strong></a>Es un patrón de diseño creacional que proporciona una interfaz para crear objetos en una superclase, mientras permite a las subclases alterar el tipo de objetos que se crearán.</li>
	<li><a href="https://refactoring.guru/es/design-patterns/abstract-factory" <strong>Abstract Factory (Fábrica abstracta):</strong></a>patrón de diseño creacional que permite producir familias de objetos relacionados sin especificar sus clases concretas.</li>
	<li><a href="https://refactoring.guru/es/design-patterns/builder"><strong>Builder (Contructor):</strong></a> patrón de diseño creacional que permite construir objetos complejos paso a paso. Este patrón permite producir distintos tipos y representaciones de un objeto empleando el mismo código de construcción.</li>
	<li><a href="https://refactoring.guru/es/design-patterns/prototype"><strong>Prototype (Prototipo,Clon,Clone):</strong></a>patrón de diseño cracional que nos permite copiar objetos existentes sin que el código dependa de sus clases.</li>
	<li><a href="https://refactoring.guru/es/design-patterns/singleton"><strong>Singleton (Instancia única):</strong></a>es un patrón de diseño creacional que nos permite asegurarnos de que una clase tenga una única instancia, a la vez que proporciona un punto de acceso global a dicha instancia.</li>
</ul>
<h4 style="color: white">Patrones Estructurales</h4>
<p style="color: white;">Los patrones estructurales explican cómo ensamblar objetos y clases en estructuras más grandes, a la vez que se mantiene la flexibilidad y eficiencia de estas estructuras.</p>
<ul style="color: white;">
	<li><a href="https://refactoring.guru/es/design-patterns/adapter"><strong>Adapter (Adaptador, Envoltorio, Wrapper):</strong></a> patrón de diseño estructural que permite la colaboración entre objetos con interfaces incompatibles.</li>
	<li><a href="https://refactoring.guru/es/design-patterns/bridge"><strong>Bridge (Puente):</strong></a> patrón de diseño estructural que te permite dividir una clase grande, o un grupo de clases estrechamente relacionadas, en dos jerarquías separadas (abstracción e implementación) que pueden desarrollarse independientemente la una de la otra.

</li>
<li><a href="https://refactoring.guru/es/design-patterns/composite"><strong>Composite (Objeto Compuesto, Object Tree):</strong></a> patrón de diseño estructural que te permite componer objetos en estructuras de árbol y trabajar con esas estructuras como si fueran objetos individuales.

</li>
<li><a href="https://refactoring.guru/es/design-patterns/decorator"><strong>Decorator (Decorador, Envoltorio, Wrapper):</strong></a> patrón de diseño estructural que te permite añadir funcionalidades a objetos colocando estos objetos dentro de objetos encapsuladores especiales que contienen estas funcionalidades.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/facade"><strong>Facade (Fachada):</strong></a> patrón de diseño estructural que proporciona una interfaz simplificada a una biblioteca, un framework o cualquier otro grupo complejo de clases.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/flyweight"><strong>Flyweight (Peso Mosca, Peso Ligero, Cache):</strong></a> patrón de diseño estructural que te permite mantener más objetos dentro de la cantidad disponible de RAM compartiendo las partes comunes del estado entre varios objetos en lugar de mantener toda la información en cada objeto.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/proxy"><strong>Proxy:</strong></a> patrón de diseño estructural que te permite proporcionar un sustituto o marcador de posición para otro objeto. Un proxy controla el acceso al objeto original, permitiéndote hacer algo antes o después de que la solicitud llegue al objeto original.

</li>
<h4 style="color: white;">Patrones de Comportamiento</h4>
<p style="color: white;">Los patrones de comportamiento tratan con algoritmos y la asignación de responsabilidades entre objetos.</p>
<ul style="color: white;">
	<li><a href="https://refactoring.guru/es/design-patterns/chain-of-responsibility"><strong>Chain of Responsability (CoR, Chain of Command):</strong></a>  patrón de diseño de comportamiento que te permite pasar solicitudes a lo largo de una cadena de manejadores. Al recibir una solicitud, cada manejador decide si la procesa o si la pasa al siguiente manejador de la cadena.

</li>
<li><a href="https://refactoring.guru/es/design-patterns/command"><strong>Command (Comando, Orden, Action, Transaction):</strong></a>  patrón de diseño de comportamiento que convierte una solicitud en un objeto independiente que contiene toda la información sobre la solicitud. Esta transformación te permite parametrizar los métodos con diferentes solicitudes, retrasar o poner en cola la ejecución de una solicitud y soportar operaciones que no se pueden realizar.

</li>
<li><a href="https://refactoring.guru/es/design-patterns/iterator"><strong>Iterator (Iterador):</strong></a>  patrón de diseño de comportamiento que te permite recorrer elementos de una colección sin exponer su representación subyacente (lista, pila, árbol, etc.).

</li>
<li><a href="https://refactoring.guru/es/design-patterns/mediator"><strong>Mediator (Mediador, Intermediary, Controller):</strong></a>   patrón de diseño de comportamiento que te permite reducir las dependencias caóticas entre objetos. El patrón restringe las comunicaciones directas entre los objetos, forzándolos a colaborar únicamente a través de un objeto mediador.

</li>
<li><a href="https://refactoring.guru/es/design-patterns/memento"><strong>Memento (Recuerdo, Instantánea, Snapshot):</strong></a>   es un patrón de diseño de comportamiento que te permite guardar y restaurar el estado previo de un objeto sin revelar los detalles de su implementación.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/observer"><strong>Observer (Observador, Publicación-Suscripción, Modelo-Patrón, Event-Subscriber, Listener):</strong></a> patrón de diseño de comportamiento que te permite definir un mecanismo de suscripción para notificar a varios objetos sobre cualquier evento que le suceda al objeto que están observando.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/state"><strong>State (Estado):</strong></a> patrón de diseño de comportamiento que permite a un objeto alterar su comportamiento cuando su estado interno cambia. Parece como si el objeto cambiara su clase.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/strategy"><strong>Strategy (Estrategia):</strong></a>  patrón de diseño de comportamiento que te permite definir una familia de algoritmos, colocar cada uno de ellos en una clase separada y hacer sus objetos intercambiables.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/template-method"><strong>Template Method (Método plantilla):</strong></a>  patrón de diseño de comportamiento que te pepatrón de diseño de comportamiento que define el esqueleto de un algoritmo en la superclase pero permite que las subclases sobrescriban pasos del algoritmo sin cambiar su estructura.
</li>
<li><a href="https://refactoring.guru/es/design-patterns/visitor"><strong>Visitor (Visitante):</strong></a>   patrón de diseño de comportamiento que te permite separar algoritmos de los objetos sobre los que operan.
</li>
</body>
</body>
</html>
